# Generated by sila2.code_generator; sila2.__version__: 0.8.0
from __future__ import annotations

import logging
from functools import partial
from queue import Queue
from typing import List, Optional, Union, cast

from sila2.framework import Command, Feature, FullyQualifiedIdentifier, Metadata, Property
from sila2.server import MetadataDict, SilaServer

from sila_cetoni.application.system import ApplicationSystem, CetoniApplicationSystem
from sila_cetoni.io.device_drivers import DigitalOutChannelInterface
from sila_cetoni.io.device_drivers import State as DigIOState
from sila_cetoni.utils import PropertyUpdater, not_equal

from ..generated.digitaloutchannelcontroller import (
    DigitalOutChannelControllerBase,
    DigitalOutChannelControllerFeature,
    InvalidChannelIndex,
    SetOutput_Responses,
)
from ..generated.digitaloutchannelcontroller import State as DataTypeState

logger = logging.getLogger(__name__)


@CetoniApplicationSystem.monitor_traffic
class DigitalOutChannelControllerImpl(DigitalOutChannelControllerBase):
    __system: ApplicationSystem
    __channels: List[DigitalOutChannelInterface]
    __channel_index_metadata: Metadata[int]
    __state_queues: List[Queue[DataTypeState]]  # same number of items and order as `__channels`

    def __init__(self, server: SilaServer, channels: List[DigitalOutChannelInterface]):
        super().__init__(server)
        self.__system = ApplicationSystem()  # type: ignore
        self.__channels = channels
        self.__channel_index_metadata = cast(Metadata[int], DigitalOutChannelControllerFeature["ChannelIndex"])

        self.__state_queues = []
        for i in range(len(self.__channels)):
            queue = Queue()
            self.__state_queues += [queue]

            self.run_periodically(
                PropertyUpdater(
                    lambda: self.__channels[i].state,
                    not_equal,
                    partial(self.update_State, queue=queue),
                    when=self.__system.state.is_operational,
                ),
            )

    def get_NumberOfChannels(self, *, metadata: MetadataDict) -> int:
        return len(self.__channels)

    def State_on_subscription(self, *, metadata: MetadataDict) -> Optional[Queue[DataTypeState]]:
        channel_index: int = metadata[self.__channel_index_metadata]
        try:
            if channel_index < 0:
                raise IndexError
            return self.__state_queues[channel_index]
        except IndexError:
            raise InvalidChannelIndex(
                message=f"The sent channel index {channel_index} is invalid. The index must be between 0 and {len(self.__channels) - 1}.",
            )

    def SetOutput(self, State: DataTypeState, *, metadata: MetadataDict) -> SetOutput_Responses:
        channel_index: int = metadata[self.__channel_index_metadata]
        logger.debug(f"channel id: {channel_index}")
        try:
            self.__channels[channel_index].state = DigIOState(State)
            return SetOutput_Responses()
        except IndexError:
            raise InvalidChannelIndex(
                message=f"The sent channel index {channel_index} is invalid. The index must be between 0 and {len(self.__channels) - 1}.",
            )

    def get_calls_affected_by_ChannelIndex(
        self,
    ) -> List[Union[Feature, Command, Property, FullyQualifiedIdentifier]]:
        return [
            cast(Property, DigitalOutChannelControllerFeature["State"]),
            cast(Command, DigitalOutChannelControllerFeature["SetOutput"]),
        ]
